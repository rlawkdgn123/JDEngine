00_JDEngine_Base
│
├─ EngineCore/       → 수학, 시간, 입력 등 (EngineCore.lib)
├─ Renderer/         → DirectX, Vulkan 등 API 렌더링 계층
├─ GameFramework/    → Scene, GameObject, Component 등
├─ Editor/           → 툴 UI용 프로젝트 (별도 EXE)
├─ Game/             → 게임 루틴 (main함수 포함)
├─ External/         → 외부 라이브러리 (glm, stb, imgui 등)
└─ Common/           → 공용 헤더 및 유틸

Base 단계 : 엔진의 구성하는데 필요한 근본적인 시스템을 지원
1. 디버그 (EngineDebug)
2. 파일 입출력 (EnginePath, EngineDirectory, EngineFile, EngineSerializer)
3. 문자열 (EngineString)
4. 수학/물리 연산 (EngineMath)
5. 객체 이름, 활성화 여부 지정 (Object)
6. 리소스 경로 관리 (EngineResources)
7. 시간(EngineTimer)
8. 시간을 활용한 이벤트 기능 지원 (TimeEvent)
9. 유한상태기계(FSM) 기반 동작 제어 (FSMStateManager)


Platform 단계 : 어떤 운영체제(OS)에서 구동될 것인지, OS에서 지원해줘야하는 기능들을 객체화한 클래스들
1. 윈도우 창 설정 및 윈도우 메시지 처리 (EngineWindow) : 윈도우 운영체제의 구동 기능들이 망라된 핵심 클래스
2. 입력 버퍼 (EngineInput) : 키보드 입력 처리 (마우스는 EngineWindow에서 처리)
3. 이미지 리소스 출력 (EngineWinImage) 
4. 사운드 출력(EngineSound)
5. 기타 외부 라이브러리(서드파티) 


GameEngine 단계
1. 게임 엔진 (EngineCore) : 프로그램 실행 시 필요한 초기 세팅 기능 지원, 게임 리소스(이미지, 사운드) 업로드, 프로그램이 종료되지 않도록 무한 반복문(Loop) 구동 및 실시간 변동사항 업데이트(Time, Tick, Render, Event, Release)
 
2. 리소스 관리(ImageManager) : 이미지 로드 및 애니메이션 기능 지원
 
3. 오브젝트
3-1. Level : 현재 윈도우 화면에 출력되고 있는 단계. 스테이지가 될 수도 있고, 타이틀 화면, 플레이 화면, 엔딩 화면으로 구분할 수도 있다. 또는 월드, 던전으로 구분될 수도 있다. 게임 장르에 따라, 게임 구성에 따라 레벨의 정의는 다를 수 있다.
 
3-2. Actor : 화면에 출력될 대상을 총 망라한 객체. 화면에 출력이 되어야하는 모든 대상은 Actor를 상속받아야 한다.
3-2-1. GameMode : 게임의 규칙을 정의하는 클래스. 
3-2-2. Component : Actor에 종속되는 대상. 즉, Actor를 이루는데 필요한 부품 ex). 렌더러, 충돌체
3-2-2-1. ActorComponent : 크기, 위치를 가지지 않고 화면에 출력되지 않는 로직이나 데이터를 처리할 목적만을 가진 기능들을 정의하는 클래스 (ex. 몬스터 AI, 체력 관리 로직, 오디오 등)
3-2-2-2. SceneComponent : 크기, 위치를 가지고 화면에 출력이 가능한 요소들 (ex. 메시, 파티클, 빛 등)
3-2-2-3. Renderer : 화면에 Actor가 출력되도록 하는 기능들이 결집된 클래스
3-2-2-4. Collision : 충돌과 관련된 모든 로직을 처리하는 클래스



Contents 단계 : 실제 게임의 세계와 컨텐츠를 생산하는 게임 클라이언트 프로그래머의 영역
1. 컨텐츠 엔진 (ContentsCore) : 창 크기, 리소스 로드 등 진짜 게임의 장르와 컨셉에 맞게 설정해야할 값을 게임 엔진에 간접적으로 전달해주는 클래스
2. 게임 모드 (GameMode) : 레벨마다 구성해야할 요소들을 정의하는 클래스. (플레이어를 출력할건지, 맵은 있는지, 배경은 띄울건지, 몬스터가 있는지, 포탈은 있는지, 타이틀 화면인지, 플레이 화면인지, 던전 로딩 화면인지, 엔딩 화면인지 등등 게임 세계의 규칙을 정의하는 클래스. GameEngine 단계의 GameMode를 상속받아서 자유롭게 설정한다. 
Actor의 무대를 어떻게 구성할건지를 정의한다.
항상 ContentsCore 이후에 동작하며, Level의 통제를 받아 메모리에 할당되고 해제된다.)
3. 플레이어
4. 맵
5. 맵 오브젝트
6. 아이템
7. 몬스터
8. UI
9. Scene
등등등

 
Application 
1. 프로그램의 시작경로(Main) : exe 실행파일의 진입점


 
 
 

# 엔진 설계 원칙

1. 상위 클래스는 하위 클래스의 존재를 알아서는 안된다.
 - Level 0 Base 의 클래스는 Level 1 Platform, Level 2 GameEngine의 클래스들의 존재를 몰라야 한다.
 - 클래스의 독립성을 지키기 위해서
 - 하위 클래스는 상위 클래스를 활용하여 각종 기능을 생산해낼 것인데, 상위 클래스가 하위 클래스를 이용하게 되면 클래스 설계가 어려워진다. 서로를 참조하게되는 문제가 발생할 수도 있고, 결정적으로 엔진을 다른 게임 프로젝트로 옮기기 어려워진다. Base가 Platform 클래스의 존재를 안다면, Base는 특정 OS에 종속된다. 
 - 만약, 독립성을 지켰다면, OS가 윈도우에서 안드로이드로 변경되더라도 Base는 그대로 안드로이드 프로젝트로 가져갈 수 있지만, 독립성을 지키지 않으면 Base도 그저 윈도우에서 구동되는 코드일 뿐이다.
 - 마찬가지로 게임엔진이 컨텐츠 단계의 클래스를 알아서는 안된다. 알게 되는 순간 그 게임 엔진은 그 게임만을 위한 엔진이 되어버린다. 
 - 예를 들어, RPG를 만들던 게임 엔진이 컨텐츠 단계에 개입하면 그 엔진으로 리듬게임을 만들기엔 게임 장르가 완전히 달라 엔진을 수정하는 노력이나 엔진을 처음부터 다시 설계하는 노력이나 비슷하게 들어간다. 즉, 게임 엔진을 재사용하여 게임을 제작하기 어렵다.
 
2. 상속을 적극 활용한다.
 - 1번의 원칙으로 인해 발생하는 어려움이 있다. "하위 단계는 상위 단계의 기능에 종속적인데, 게임 개발 환경에 따라 달라지는 문제를 어떻게 해결할 것인가?"
 - 이를 해결하는 방법이 상속을 적극 활용하는 것이다.
 - 인터페이스 클래스를 만들고 하위 단계에서 상속을 받아 인터페이스 클래스에 있는 내용들을 수정/정의 함으로써 상위 단계에서 지원하는 기능을 간접적으로 수정할 수 있다.
 
3. 코딩 스탠다드를 준수한다.
- 엔진과 관련되면 클래스의   첫 글자는 U로 시작한다.
- Actor의 상속을 받으면 클래스의 첫 글자는 A로 시작한다.
- 변수와 함수 모두 첫 글자는 대문자를 쓴다.
- 매개변수의 첫글자는 언더바( _ )를 사용한다.
- 외부에서의 멤버의 접근은 Getter/Setter 함수를 사용한다.
- 코드는 명시적으로 작성한다. 
  - C++ 스타일 명시적 형변환 사용