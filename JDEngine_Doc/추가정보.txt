# DirectX 11 기반 2D 게임 엔진 설계 가이드

## 1. 전체적인 엔진 프레임워크 구조 및 모듈 구성

DirectX11을 기반으로 2D 전용 게임 엔진을 만들 때는 **모듈화된 구조**를 갖추는 것이 중요합니다[numberanalytics.com](https://www.numberanalytics.com/blog/game-engine-architecture-essentials#:~:text=Modularity). 각 모듈은 서로 역할을 분담하여 엔진의 다양한 기능을 책임집니다. 아래는 기본적인 모듈들과 그 역할입니다:

- **엔진 코어(Core)와 게임 루프**: 엔진의 중심으로, 초기화와 종료, 메인 게임 루프를 담당합니다. 예를 들어 윈도우 창 생성, DirectX 디바이스/스왑체인 초기화, 리소스 로드 등을 수행하고 게임이 끝날 때까지 **무한 루프**를 돌립니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=GameEngine%20%EB%8B%A8%EA%B3%84%201,Time%2C%20Tick%2C%20Render%2C%20Event%2C%20Release). 루프 내에서 각 프레임마다 **입력 처리 → 게임 업데이트 → 충돌 판정 → 렌더링 → 프레임 출력**의 순서로 진행됩니다. 엔진 코어는 각 모듈을 초기화하고 매 프레임 그 모듈들의 함수를 호출하는 **조율자** 역할을 합니다.
- **플랫폼/윈도우 관리**: **EngineWindow**와 같은 모듈로, **윈도우 창 생성과 메시지 처리**를 담당합니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=Platform%20%EB%8B%A8%EA%B3%84%20%3A%20%EC%96%B4%EB%96%A4%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C,%EA%B8%B0%ED%83%80%20%EC%99%B8%EB%B6%80%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%28%EC%84%9C%EB%93%9C%ED%8C%8C%ED%8B%B0). DirectX11은 Win32 기반이므로 윈도우 API로 창을 만들고, 윈도우 메시지(키 입력, 마우스 이동 등)를 처리하는 루프를 포함합니다. (키보드/마우스 입력은 윈도우 메시지 콜백으로 처리하거나 별도 입력 모듈에서 처리합니다.) 이 계층은 운영체제 종속 기능을 캡슐화하여 엔진이 OS에 맞게 동작하도록 합니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=Platform%20%EB%8B%A8%EA%B3%84%20%3A%20%EC%96%B4%EB%96%A4%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C,%EA%B8%B0%ED%83%80%20%EC%99%B8%EB%B6%80%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%28%EC%84%9C%EB%93%9C%ED%8C%8C%ED%8B%B0).
- **입력(Input) 모듈**: 키보드, 마우스 (또는 게임패드)의 **입력 상태를 관리**합니다. 예를 들어 `EngineInput` 클래스가 현재 어떤 키가 눌렸는지, 마우스 좌표는 어디인지 등을 매 프레임 업데이트하여 게임 오브젝트나 게임 로직에서 쓸 수 있게 제공합니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=Platform%20%EB%8B%A8%EA%B3%84%20%3A%20%EC%96%B4%EB%96%A4%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C,%EA%B8%B0%ED%83%80%20%EC%99%B8%EB%B6%80%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%28%EC%84%9C%EB%93%9C%ED%8C%8C%ED%8B%B0). 입력 모듈은 윈도우에서 받은 입력 이벤트를 받아 상태를 갱신하거나 DirectInput/XInput 등을 이용할 수도 있습니다.
- **렌더링(그래픽스) 모듈**: DirectX11의 Direct3D를 사용하여 **스프라이트나 2D 이미지들을 화면에 그리는 역할**을 합니다. 2D이지만 Direct3D 파이프라인을 이용하므로, 정점 버퍼에 사각형 정점과 텍스처 좌표를 설정해 그리는 방식으로 동작합니다[fn000.tistory.com](https://fn000.tistory.com/13#:~:text=,6%EA%B0%9C%EC%9D%98%20%EC%A0%95%EC%A0%90)[nagie.tistory.com](https://nagie.tistory.com/157#:~:text=,%ED%95%9C%20%EB%8B%AC%EC%9D%84%20%EB%84%98%EA%B8%B4%20%EA%B1%B0%20%EA%B0%99%EB%8B%A4). 이 모듈은 **Renderer** 혹은 **GraphicsDevice** 클래스로 구현되며, DirectX의 **디바이스(Device)**와 **디바이스 컨텍스트(Context)**를 보유하고 게임 오브젝트들이 요청한 그리기 작업을 수행합니다. 예를 들어 `Renderer.DrawSprite(texture, position)` 등의 인터페이스를 제공해 스프라이트를 그리도록 하고, 내부에서 DirectX11의 그리기 호출을 수행합니다. 또한 **카메라** 개념을 도입하여 가상 좌표계를 실제 화면에 투영해 다양한 해상도를 지원할 수 있습니다 (필요하다면 **뷰 행렬**을 사용하여 2D에서도 카메라 이동/확대를 구현).
- **자원 관리(Resource Manager)**: 텍스처 이미지, 사운드, 폰트 등의 **게임 리소스를 로드/관리**하는 모듈입니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=2,%EB%A1%9C%EB%93%9C%20%EB%B0%8F%20%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B8%B0%EB%8A%A5%20%EC%A7%80%EC%9B%90). 예컨대 `ImageManager`를 두어 이미지 파일을 로드하고 관리하며, 애니메이션 프레임용 스프라이트시트도 이 모듈에서 취급합니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=2,%EB%A1%9C%EB%93%9C%20%EB%B0%8F%20%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B8%B0%EB%8A%A5%20%EC%A7%80%EC%9B%90). 동일한 리소스가 반복 로드되지 않게 **싱글턴**으로 전역 관리하거나 캐싱 기법을 사용합니다. 또한 DirectX의 경우 COM 객체(`ID3D11ShaderResourceView` 등) 해제를 위해 엔진 종료 시 리소스 매니저가 보유한 객체들을 **Release**하는 작업도 담당합니다.
- **오디오(Audio) 모듈**: **사운드 효과와 배경음악 재생**을 담당합니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=Platform%20%EB%8B%A8%EA%B3%84%20%3A%20%EC%96%B4%EB%96%A4%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C,%EA%B8%B0%ED%83%80%20%EC%99%B8%EB%B6%80%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%28%EC%84%9C%EB%93%9C%ED%8C%8C%ED%8B%B0). XAudio2, DirectSound 또는 외부 오디오 라이브러리를 사용하여 구현할 수 있습니다. `EngineSound` 클래스 등을 만들어 소리 리소스를 로드하고, 재생/정지, 볼륨 조절 등을 관리합니다. 이 모듈도 초기화 시 사운드 장치를 세팅하고, 게임 종료 시 자원을 해제합니다.
- **게임 월드 및 씬/레벨 관리**: 게임 엔진은 보통 **씬(Scene) 혹은 레벨(Level)** 개념을 통해 다양한 게임 상태를 관리합니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=3,%EB%A0%88%EB%B2%A8%EC%9D%98%20%EC%A0%95%EC%9D%98%EB%8A%94%20%EB%8B%A4%EB%A5%BC%20%EC%88%98%20%EC%9E%88%EB%8B%A4). 예를 들어 메뉴 화면, 게임 플레이 화면, 엔딩 화면 등을 각각 하나의 **Level**로 정의하고 관리하는 **SceneManager**를 둡니다. SceneManager는 현재 활성화된 씬을 업데이트하고, 씬 전환이 필요하면 새로운 씬을 로드/초기화하며 이전 씬의 오브젝트를 정리합니다. 이러한 **상태 관리**를 통해 초보 개발자가 흔히 겪는 “중앙 Game 클래스에서 상태별로 분기 처리”하는 복잡함을 줄이고, 씬 단위로 게임 로직을 캡슐화할 수 있습니다[reddit.com](https://www.reddit.com/r/gamedev/comments/43kpzg/proper_2d_game_engine_structure/#:~:text=emulate%20structures%20from%20game%20engines,rooms%20from%20game%20maker)[reddit.com](https://www.reddit.com/r/gamedev/comments/43kpzg/proper_2d_game_engine_structure/#:~:text=match%20at%20L501%20structures%20like,the%20details%20of%20your%20particular).
- **게임 오브젝트와 컴포넌트 시스템**: 게임 내에 등장하는 **모든 객체(캐릭터, 적, 총알, 배경 등)**를 추상화한 **GameObject**(또는 Actor) 클래스를 설계합니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=3,%EA%B4%80%EB%A0%A8%EB%90%9C%20%EB%AA%A8%EB%93%A0%20%EB%A1%9C%EC%A7%81%EC%9D%84%20%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94%20%ED%81%B4%EB%9E%98%EC%8A%A4). 각 GameObject는 위치/크기 정보를 가지며(Transform 컴포넌트), 자신만의 **컴포넌트(Components)** 목록을 가져 다양한 속성을 부여합니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=3,%EA%B4%80%EB%A0%A8%EB%90%9C%20%EB%AA%A8%EB%93%A0%20%EB%A1%9C%EC%A7%81%EC%9D%84%20%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94%20%ED%81%B4%EB%9E%98%EC%8A%A4). 예를 들어 `SpriteRenderer` 컴포넌트를 붙이면 화면에 그림이 그려지고, `Collider` 컴포넌트를 붙이면 충돌 판정을 가질 수 있습니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=3,%EA%B4%80%EB%A0%A8%EB%90%9C%20%EB%AA%A8%EB%93%A0%20%EB%A1%9C%EC%A7%81%EC%9D%84%20%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94%20%ED%81%B4%EB%9E%98%EC%8A%A4). 이러한 **컴포넌트 기반 설계**를 통해 객체 간 **상속 관계를 복잡하게 만들지 않고도** 필요한 기능을 조합하여 구성할 수 있습니다. GameObject들을 일괄 관리하는 **오브젝트 관리자**(예: 현재 씬 내 오브젝트 리스트)도 필요합니다. 이 관리자는 매 프레임 각 오브젝트의 업데이트(Update)와 렌더(Render)를 호출하고, 오브젝트 추가/삭제를 처리합니다.
- **물리 및 충돌(Physics/Collision) 모듈**: 2D 게임에서는 주로 단순한 **충돌 판정**만 필요할 경우가 많지만, 이를 체계적으로 관리할 모듈이 있으면 좋습니다. Collider 컴포넌트로부터 충돌 형상(AABB나 원 등)을 수집하여 **충돌 검사**를 수행하고, 충돌 이벤트를 발생시켜 게임 오브젝트에 알리거나 물리 반응(반발, 중력 등 간단한)**을 처리**하는 시스템입니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=3,%EA%B4%80%EB%A0%A8%EB%90%9C%20%EB%AA%A8%EB%93%A0%20%EB%A1%9C%EC%A7%81%EC%9D%84%20%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94%20%ED%81%B4%EB%9E%98%EC%8A%A4). 복잡한 물리 시뮬레이션까지는 아니더라도, **충돌 엔진**이 분리되어 있으면 향후 물리 효과를 확장하기 좋습니다. 예를 들어 `PhysicsSystem`이나 `CollisionManager`를 두어 매 프레임 모든 콜라이더를 검사하고 겹치는 경우 해당 객체들에 통지하도록 구현합니다. (객체들에게 `OnCollision()` 같은 함수를 두어 콜백하거나, 중앙에서 이벤트 디스패치.)
- **애니메이션 시스템**: 2D 엔진의 애니메이션은 주로 스프라이트 시트(Sprite Sheet) 기반 프레임 애니메이션입니다. **Animation 모듈**은 스프라이트 애니메이션 클립(프레임들의 집합)과 현재 재생 상태를 관리합니다. 예를 들어 `AnimationComponent`를 만들어 한 오브젝트가 여러 애니메이션 상태(대기, 걷기, 공격 등)를 갖고 프레임을 변화시킬 수 있게 합니다. 이 모듈은 타이머나 델타 시간을 이용해 **정해진 간격으로 프레임을 전환**하며, 현재 프레임에 해당하는 텍스처를 SpriteRenderer에 넘겨주는 식으로 동작할 수 있습니다. 애니메이션 데이터는 ResourceManager와 연계하여 스프라이트 시트에서 특정 순서의 이미지를 참조하도록 설계합니다.
- **UI 및 폰트 렌더링 모듈**: 게임 내 **사용자 인터페이스 (체력바, 메뉴 버튼 등)**를 그리는 모듈입니다. UI는 일반 게임 오브젝트와 별도로 화면 좌표계(픽셀 좌표)에 고정되어 렌더링될 수 있습니다. DirectX11에서는 Direct2D/DirectWrite를 활용하거나, SpriteBatch를 이용해 폰트 텍스처를 그리는 방법 등이 있습니다. UI용으로 `UIManager`나 전용 UI 객체 클래스를 만들어, **계층적 UI 구성**(예: 화면에 고정된 Canvas -> UI 위젯들)을 다룰 수 있습니다. UI도 하나의 씬에 포함시킬 수도 있고, 별도로 처리할 수도 있지만, **렌더링 순서**는 게임 월드의 스프라이트보다 나중에 그려지도록 조정해야 합니다 (예: HUD가 캐릭터 위에 오도록).

以上의 모듈들은 서로 적절히 **분리**되어 있지만, 엔진 코어를 통해 필요 시 상호작용합니다. 가령, 엔진 코어는 초기화 시 그래픽스/오디오/입력 모듈을 모두 세팅하고 각 모듈 인스턴스를 다른 모듈들이 참조할 수 있도록 넘겨줄 수 있습니다. **그림으로 표현**하면, 엔진(Core)은 중앙에 있고 주변에 렌더링 엔진, 물리 엔진, 사운드 시스템 등이 있으며, 엔진은 각 모듈을 초기화하고 업데이트 때 호출합니다[numberanalytics.com](https://www.numberanalytics.com/blog/game-engine-architecture-essentials#:~:text=The%20following%20diagram%20illustrates%20the,of%20a%20game%20engine%20architecture). 또한 렌더링 엔진은 DirectX11 **그래픽 API**를, 오디오 시스템은 XAudio2 등의 **오디오 API**를 내부적으로 사용하여 실제 하드웨어와 소통합니다[numberanalytics.com](https://www.numberanalytics.com/blog/game-engine-architecture-essentials#:~:text=graph%20LR%20A%5B%22Game%20Engine%22%5D%20,G%5B%22Audio%20Middleware).

## 2. 모듈 간 낮은 결합도와 객체지향적 설계 구조

게임 엔진을 잘 설계하려면 각 모듈과 클래스가 **명확한 책임**을 가지고, 서로 **낮은 결합도**를 유지하도록 해야 합니다[numberanalytics.com](https://www.numberanalytics.com/blog/game-engine-architecture-essentials#:~:text=Modularity). 이를 위해 적용할 수 있는 객체지향 설계 원칙과 예시는 다음과 같습니다:

- **계층 구조와 의존성 역전**: 엔진 코드를 계층별로 분리하고 **상위 계층이 하위 계층 구현에 직접 의존하지 않도록** 합니다. 예를 들어 **Base/Platform** 계층, **Engine** 계층, **Game(Contents)** 계층을 나누었다면, **상위 계층의 클래스는 하위 계층의 존재를 알아서는 안 된다**는 원칙을 지킵니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=1,%EA%B7%B8%20%EA%B2%8C%EC%9E%84%EB%A7%8C%EC%9D%84%20%EC%9C%84%ED%95%9C%20%EC%97%94%EC%A7%84%EC%9D%B4%20%EB%90%98%EC%96%B4%EB%B2%84%EB%A6%B0%EB%8B%A4). 플랫폼(Platform) 계층의 세부 구현 (예: Windows용 Window 클래스)이 엔진의 코어에서 추상 인터페이스로 쓰이고, 나중에 OS가 바뀌더라도 엔진 코어는 수정 없이 동작하게 만드는 식입니다. 이렇게 하면 엔진을 다른 프로젝트나 다른 플랫폼에 **재사용**하기 쉽고, 한 모듈을 바꿔도 다른 부분에 영향이 최소화됩니다.
- **인터페이스와 구현 분리**: 서로 결합도를 낮추기 위해 **추상 클래스 또는 인터페이스**를 적극 활용합니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=%ED%95%B4%EA%B2%B0%ED%95%A0%20%EA%B2%83%EC%9D%B8%EA%B0%80%3F%22%20,%EA%B8%B0%EB%8A%A5%EC%9D%84%20%EA%B0%84%EC%A0%91%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EC%88%98%EC%A0%95%ED%95%A0%20%EC%88%98%20%EC%9E%88%EB%8B%A4). 예를 들어, 렌더링 시스템에 `IRenderer` 인터페이스를 정의하고, 이를 구현한 `DX11Renderer` 클래스를 사용하면 엔진의 다른 부분(예: 게임 로직)은 `IRenderer`만 알면 됩니다. 나중에 구현을 바꾸거나(OpenGL로 교체 등) 추가하더라도 다른 부분에 큰 변경이 없습니다. 또한 입력 시스템도 `IInput` 같은 인터페이스로 키 상태를 얻는 함수를 정의하고, 실제 구현은 DirectInput을 쓰든 WinAPI를 쓰든 간에 인터페이스만 일치시키면 되도록 할 수 있습니다. 이처럼 **의존성 역전 원칙(DIP)**을 적용하면 모듈 간 결합도를 낮추고 유연성을 높일 수 있습니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=1,%EA%B7%B8%20%EA%B2%8C%EC%9E%84%EB%A7%8C%EC%9D%84%20%EC%9C%84%ED%95%9C%20%EC%97%94%EC%A7%84%EC%9D%B4%20%EB%90%98%EC%96%B4%EB%B2%84%EB%A6%B0%EB%8B%A4).
- **컴포넌트 기반 설계**: 앞서 설명한 GameObject-Component 구조는 **높은 응집도와 낮은 결합도**를 구현하는 데 효과적입니다. 각 컴포넌트 클래스는 자신의 역할(렌더링, 충돌, AI 등)만 수행하여 **단일 책임 원칙(SRP)**을 따르고, GameObject는 컴포넌트를 보관하지만 세부 구현에는 의존하지 않습니다. 예를 들어 GameObject는 컴포넌트들의基底 클래스 포인터(예: `Component*`) 리스트만 가지고, 컴포넌트 추가/제거 인터페이스만 제공하며, 실제 업데이트나 기능은 컴포넌트가 알아서 수행하게 합니다. 이렇게 하면 새로운 타입의 컴포넌트를 추가하더라도 GameObject나 엔진의 다른 부분을 수정할 필요 없이 확장할 수 있습니다. 또한 **다형성**을 통해 Component의 파생 클래스(SpriteRenderer, Collider 등)를 일괄 처리함으로써 결합도를 낮춥니다.
- **예시 클래스 구조**: 다음은 위의 개념들을 활용한 클래스 구조의 한 **예시**입니다 (간략화된 다이어그램):

```
plaintext
복사편집
EngineCore                      <-- 엔진의 핵심 (싱글톤으로 존재)
├── GraphicsManager (Renderer)  <-- DirectX11 디바이스/스왑체인 관리, 드로우 호출
├── InputManager                <-- 입력 상태 관리
├── AudioManager                <-- 오디오 출력 관리
├── SceneManager                <-- 현재 Scene 추적 및 전환 관리
│    └── Scene (Level)          <-- 게임 오브젝트들을 소유
│         └── [GameObject...]   <-- 여러 개의 게임 오브젝트 목록
└── ResourceManager             <-- 텍스처, 사운드 등 리소스 로딩/캐싱

```

```
plaintext
복사편집
GameObject
├── TransformComponent   <-- 위치, 회전, 크기 등
├── [Component...]       <-- 다양한 컴포넌트 (다형성 목록)
│    ├── SpriteRenderer  <-- 화면에 이미지 렌더링 (그래픽스 모듈 이용)
│    ├── Collider        <-- 충돌 영역 정의 (물리 모듈과 연계)
│    ├── AudioSource     <-- 소리 재생 (오디오 모듈 이용)
│    └── ... (etc: Script, Particle, UI, etc.)
└── Update()/Render()    <-- 컴포넌트들을 업데이트하거나 렌더링 지시

```

위 구조에서 **EngineCore**는 각 Manager를 가지고 있으며, Manager들은 서로 필요 시 EngineCore나 인터페이스를 통해서만 통신하고 **직접 다른 Manager에 의존하지 않습니다**. 예를 들어 **Physics(충돌) 모듈**은 충돌 결과를 EngineCore나 이벤트 시스템에 알려주고, 그 이벤트를 **게임 오브젝트**가 받아서 처리하게 하면 물리 → 게임 로직 방향의 결합을 줄일 수 있습니다 (Observer 패턴 활용 등). 또한 **Scene**을 분리함으로써 한 씬(Scene)의 오브젝트들은 다른 씬과 완전히 분리되어 관리되며, 씬 전환 시 서로 영향을 주지 않습니다[reddit.com](https://www.reddit.com/r/gamedev/comments/43kpzg/proper_2d_game_engine_structure/#:~:text=GameMaker%20rooms%20are%20probably%20like,The).

- **낮은 결합도를 위한 관례**: 모듈 간 상호작용은 **명시적인 경로**로 이루어지게 설계합니다. 예를 들어 InputManager는 전역으로 키 상태를 제공하지만, 게임 오브젝트가 직접 InputManager 인스턴스에 접근하기보다는 EngineCore나 Scene을 통해 필요한 입력 정보를 받도록 할 수 있습니다. 또는 **이벤트 버스(Event Bus)**나 **메시지 시스템**을 도입하여, 예를 들어 충돌 모듈이 “A와 B 충돌함” 이벤트를 발행하면 해당 오브젝트의 스크립트 컴포넌트가 이를 구독하여 처리하게 할 수 있습니다. 이렇게 하면 충돌 시스템이 게임 오브젝트의 구체 행동을 직접 호출하지 않아도 되므로 결합이 낮아집니다.
- **객체지향 디자인 패턴**: 싱글톤, 상태(State) 패턴, 팩토리 패턴 등 다양한 디자인 패턴을 적절히 활용할 수 있습니다. 예를 들어 **State 패턴**으로 게임 상태(메뉴, 플레이, 일시정지 등)를 클래스로 구현하고, SceneManager가 현재 상태 객체를 바꿔 끼우는 식으로 관리하면 if/else 분기를 줄이고 구조를 체계화할 수 있습니다. 또한 복잡한 모듈 간 통신에는 **퍼사드(Facade)**를 두어 단순한 인터페이스를 제공하거나, **전략(Strategy)** 패턴으로 알고리즘을 갈아끼우는 식의 유연한 설계도 고려 가능합니다. 중요한 것은 엔진이 **개방-폐쇄 원칙(OCP)**에 따라 확장에는 열려 있고, 수정에는 닫혀 있도록 설계하는 것입니다.

요약하면, **모듈들은 서로 최소한의 인터페이스로만 연결**되고, 각자 내부 구현은 캡슐화하여 독립성을 유지해야 합니다. 계층 구조를 지켜 상위 엔진 로직이 하위 시스템의 세부를 모르도록 하고[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=1,%EA%B7%B8%20%EA%B2%8C%EC%9E%84%EB%A7%8C%EC%9D%84%20%EC%9C%84%ED%95%9C%20%EC%97%94%EC%A7%84%EC%9D%B4%20%EB%90%98%EC%96%B4%EB%B2%84%EB%A6%B0%EB%8B%A4), 컴포넌트나 인터페이스를 통해 유연하게 기능을 조합함으로써 객체지향적 설계의 장점을 살릴 수 있습니다.

## 3. 유지보수성·확장성·효율성을 위한 엔진 설계 원칙 및 규칙

마지막으로, 초보 개발자가 게임 엔진을 만들 때 유념해야 할 **설계 원칙과 규칙**들을 정리하면 다음과 같습니다:

- **모듈성과 계층화**: 앞서 강조했듯 엔진을 모듈별로 명확히 나누고, **각 모듈은 자신의 책임만** 지도록 합니다[numberanalytics.com](https://www.numberanalytics.com/blog/game-engine-architecture-essentials#:~:text=Modularity). 렌더링 모듈은 그리기만, 물리 모듈은 충돌/물리만, 오디오 모듈은 사운드만 담당하게 분리하세요. 이렇게 하면 한 부분을 수정하거나 교체해도 다른 부분에 영향이 적고, 새 기능 추가도 수월해집니다. 또한 엔진 코어와 게임 컨텐츠를 분리하여, 엔진 자체는 특정 게임 로직에 종속되지 않게 만들어두면 재사용과 확장이 쉬워집니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=,%EC%97%94%EC%A7%84%EC%9D%84%20%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC%20%EA%B2%8C%EC%9E%84%EC%9D%84%20%EC%A0%9C%EC%9E%91%ED%95%98%EA%B8%B0%20%EC%96%B4%EB%A0%B5%EB%8B%A4).
- **게임 루프의 일관된 업데이트 순서**: 엔진에서는 **프레임별 업데이트 순서**를 정하고 지켜야 예측 가능한 동작을 얻을 수 있습니다. 일반적인 순서는 **입력 → AI/게임로직 → 물리(충돌) → 애니메이션 → 렌더링 → (다음 프레임)**입니다. 먼저 입력을 읽고, 그에 따라 게임 오브젝트의 움직임이나 행동을 업데이트한 뒤, 위치가 변한 것을 바탕으로 충돌을 검사/처리합니다. 그 다음 현재 상태에 맞게 애니메이션 프레임을 바꾸고, 최종적으로 화면에 렌더링을 합니다. 이 **순서를 코드에 명시적으로 구현**해두고 따르세요. 또한 일부 시스템은 다른 시스템보다 먼저 업데이트돼야 할 수도 있습니다. (예: **물리는 논리 업데이트 후, 렌더링 전에** 수행 등.) 필요하다면 **계층별 업데이트**를 두어, SceneManager.Update → Physics.Update → SceneManager.LateUpdate → Renderer.Draw 처럼 여러 단계로 나누어 호출합니다. Unity 엔진의 Update/LateUpdate처럼, 한 프레임 내에서도 로직과 후처리, 렌더 단계를 나누면 충돌 처리 후 위치 보정, 카메라 위치 조정 등 섬세한 제어가 가능합니다.
- **프레임 독립적인 시간 관리**: 초보 개발자가 흔히 겪는 실수는 **게임 로직이나 움직임을 프레임 레이트에 종속**시켜서, 초당 프레임수가 달라지면 게임 속도가 변하는 문제입니다[rito15.github.io](https://rito15.github.io/posts/unity-deltatime-and-fixeddeltatime/#:~:text=%ED%83%80%EA%B2%9F%20%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EB%A7%88%EB%8B%A4%20%EC%84%B1%EB%8A%A5%20%EA%B2%A9%EC%B0%A8%EB%A1%9C%20%EC%9D%B8%ED%95%B4,%EA%B2%83%EC%9D%84%20%EB%8C%80%EB%B9%84%ED%95%B4%20%EB%B3%B4%EC%A0%95%ED%95%98%EA%B8%B0%20%EC%9C%84%ED%95%B4%20%EC%82%AC%EC%9A%A9%EB%90%9C%EB%8B%A4). 이를 방지하려면 `deltaTime` (두 프레임 사이의 시간 간격)을 활용하여 이동/애니메이션 등을 **시간 기준으로 보정**해야 합니다[rito15.github.io](https://rito15.github.io/posts/unity-deltatime-and-fixeddeltatime/#:~:text=%EC%98%88%EB%A5%BC%20%EB%93%A4%EC%96%B4%20A%20%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EB%8A%94%201%EC%B4%88%EC%97%90,B%20%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EB%8A%94%201%EC%B4%88%EC%97%90%2020%ED%94%84%EB%A0%88%EC%9E%84%EC%9D%B4%20%EC%9E%AC%EC%83%9D%EB%90%9C%EB%8B%A4%EB%A9%B4). 예를 들어 물체를 프레임마다 5픽셀 이동시키는 대신, `speed * deltaTime`만큼 이동시키면 어느 PC에서나 초당 같은 거리를 움직입니다. DirectX C++에서는 `QueryPerformanceCounter`나 `chrono` 라이브러리로 고해상도 시간을 측정하고, 매 프레임 걸린 시간을 초단위로 환산한 값을 사용합니다. 더 나아가 물리 계산은 초당 고정된 횟수(예: 60Hz)로 수행하고 렌더링은 가변 프레임으로 할 수 있는데, 이는 **Fixed Time Step** 기법으로 필요에 따라 구현해볼 수 있습니다. 기본적으로는 **논리 업데이트는 Δt 보정, 필요하면 보간(Interpolation)**을 적용하여 프레임레이트와 상관없이 게임 흐름이 일정하도록 설계하세요.
- **해상도 및 화면 비율 대응**: 2D 게임이라고 해도 **다양한 해상도**에서 동작하도록 하는 것이 확장성에 좋습니다. 엔진 레벨에서 화면 좌표 처리를 추상화하여, 특정 해상도에 종속된 하드코딩을 피하세요. 예를 들어 화면 가로크기를 800으로 고정하지 말고, `Screen.Width` 값을 참조하도록 하거나 백터 좌표를 정규화된 값(0~1) 또는 월드 좌표로 처리한 뒤 카메라 변환을 통해 픽셀로 변환하도록 합니다. DirectX11에서는 **뷰포트**나 **오소그래픽 프로젝션 행렬**을 사용해 해상도와 무관한 월드 좌표계를 구성할 수 있습니다. UI 요소도 앵커/비율 기반으로 배치하면 해상도가 달라져도 올바른 위치에 나오게 할 수 있습니다. 이렇게 하면 엔진을 사용하는 게임이 다양한 화면 환경에 대응하기 쉬워집니다.
- **Singleton(싱글톤) 사용 지침**: 싱글톤은 엔진 설계에서 **자주 사용되지만 신중**해야 합니다. 전역에서 하나뿐인 인스턴스로 접근이 편리하고 메모리 낭비를 줄이는 등의 장점이 있어[hongchange.tistory.com](https://hongchange.tistory.com/entry/win32-%EA%B2%8C%EC%9E%84-%EB%A7%8C%EB%93%A4%EA%B8%B02-Core%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EC%8B%B1%EA%B8%80%ED%86%A4Singleton%EB%A7%A4%ED%81%AC%EB%A1%9C-%ED%95%A8%EC%88%98#:~:text=%EC%8B%B1%EA%B8%80%ED%86%A4%20%ED%8C%A8%ED%84%B4%EC%9D%98%20%EC%9E%A5%EC%A0%90), **Core**, **InputManager**, **AudioManager** 등을 싱글톤으로 구현하는 예가 많습니다[hongchange.tistory.com](https://hongchange.tistory.com/entry/win32-%EA%B2%8C%EC%9E%84-%EB%A7%8C%EB%93%A4%EA%B8%B02-Core%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EC%8B%B1%EA%B8%80%ED%86%A4Singleton%EB%A7%A4%ED%81%AC%EB%A1%9C-%ED%95%A8%EC%88%98#:~:text=%EC%9A%B0%EB%A6%AC%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%80%20core%ED%81%B4%EB%9E%98%EC%8A%A4%EA%B0%80%20%EC%A4%91%EC%B6%94%EA%B0%80%20%EB%90%98%EC%96%B4,%EB%8F%8C%EC%95%84%EA%B0%80%EA%B2%8C%20%EB%90%9C%EB%8B%A4). 예를 들어 Core 클래스의 인스턴스를 하나만 생성하도록 하여 전체 엔진의 중심으로 쓰거나, 여러 오브젝트가 참조해야 하는 리소스 매니저를 싱글톤으로 만들어 어디서나 `ResourceManager::Instance()`로 접근 가능하게 하면 편의성이 높습니다. 하지만 **주의할 점**은 싱글톤 남용 시 결합도가 올라가고 테스트가 어려워질 수 있다는 것입니다. 싱글톤은 숨은 전역 의존성을 만들기에, 너무 많은 시스템을 싱글톤으로 두면 각각이 서로 암묵적으로 엮여 구조를 흐트릴 수 있습니다. 가이드라인은 다음과 같습니다: *“엔진 내 정말 **전역으로 한 개만 있어야 하는 관리자 객체만** 싱글톤으로 만들고, 나머지는 필요한 범위 (예: Scene 한정, GameObject 한정)로 생명주기를 관리하라.”* 또한 싱글톤 구현 시 **멀티스레딩 환경에서의 안정성**, 객체 파괴 시점 등을 고려해야 합니다. 간단한 엔진이라면 프로그램 시작부터 끝까지 살아있는 싱글톤들이 많겠지만, 가능하다면 EngineCore 하나만 싱글톤으로 두고 나머지 매니저들은 EngineCore의 멤버로 두는 식으로 **명시적 구성**을 선호합니다. 그러면 의존 관계가 코드에 드러나 유지보수가 쉬워집니다.
- **메모리 관리와 객체 수명**: C++로 엔진을 개발한다면 메모리 관리에 각별히 신경 써야 합니다. **RAII 원칙**을 따르고 스마트 포인터(`std::unique_ptr`, `std::shared_ptr`)를 활용해 **누수(leak)**를 방지하세요. DirectX의 COM 객체(ID3D11* 인터페이스들)는 **AddRef/Release** 개념이 있으므로, COM 포인터 래퍼인 `ComPtr`(WRL 또는 COM smart pointer)을 사용하면 자동으로 Release되어 편리합니다. 또한 게임 오브젝트나 컴포넌트는 생성/소멸이 빈번할 수 있으므로, **메모리 풀**이나 객체 풀을 도입해 **동적 할당 부하**를 줄이는 것도 고려해볼 수 있습니다. 한 프레임 내에 new/delete를 반복하면 단편화와 성능 문제가 생길 수 있으므로, 엔진 레벨에서 메모리 풀링 기법을 적용하거나 **컨테이너**(예: `std::vector` 등)에 미리 객체를 할당해 두고 사용하는 것이 좋습니다. 초보 단계에서는 스마트 포인터와 범위 기반 객체로 관리하는 것만으로도 충분합니다. 그리고 **디버그 모드에서 메모리 누수 체크**를 습관화하세요[kabu0129.tistory.com](https://kabu0129.tistory.com/71?category=1267115#:~:text=%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%84%20%EC%8B%A4%ED%96%89%ED%95%98%EA%B3%A0%20%EC%A2%85%EB%A3%8C%ED%95%A0%20%EB%95%8C%EA%B9%8C%EC%A7%80%20%EB%AC%B4%ED%95%9C%ED%9E%88,%EA%B2%8C%EC%9E%84%20%EB%A3%A8%ED%94%84%EB%A5%BC%20%EB%8F%8C%EB%A0%A4%EC%A4%84%20%ED%95%B5%EC%8B%AC%20%ED%81%B4%EB%9E%98%EC%8A%A4). Visual C++의 `_CRTDBG`나 엔진에 메모리 추적 기능을 넣어두면, 엔진 종료 시 해제 안 된 메모리를 출력하여 문제를 조기에 발견할 수 있습니다[kabu0129.tistory.com](https://kabu0129.tistory.com/71?category=1267115#:~:text=1,%EB%A9%94%EC%8B%9C%EC%A7%80%20%EB%A3%A8%ED%94%84%EC%97%90%20%EC%A0%84%EB%8B%AC%ED%95%A0%20%ED%95%A8%EC%88%98%EB%93%A4%20%EC%9E%85%EB%A0%A5).
- **코딩 컨벤션과 문서화**: 유지보수성을 위해 **일관된 코딩 스타일**과 **명확한 이름짓기**를 지켜야 합니다. 엔진 코드와 게임 코드의 네이밍을 구분하고, 클래스/함수의 역할이 드러나도록 합니다. 예컨대 어떤 블로그에서는 엔진 레벨 클래스 앞에 `U` 접두어를 붙이고[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=3.%20%EC%BD%94%EB%94%A9%20%EC%8A%A4%ED%83%A0%EB%8B%A4%EB%93%9C%EB%A5%BC%20%EC%A4%80%EC%88%98%ED%95%9C%EB%8B%A4.%20,%EC%BD%94%EB%93%9C%EB%8A%94%20%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4), 게임 플레이(컨텐츠) 클래스에는 `A`(Actor) 접두어를 붙이는 식으로 구분하기도 합니다[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=3.%20%EC%BD%94%EB%94%A9%20%EC%8A%A4%ED%83%A0%EB%8B%A4%EB%93%9C%EB%A5%BC%20%EC%A4%80%EC%88%98%ED%95%9C%EB%8B%A4.%20,%EC%BD%94%EB%93%9C%EB%8A%94%20%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4). 또한 중요한 함수에는 주석을 달고, 모듈 간 인터페이스는 문서화해두는 것이 좋습니다. 초보 개발자일수록 나중에 자기 코드를 봤을 때 이해하기 어렵기 때문에, **자기 자신을 위한 설명**을 충분히 남겨두세요. 그리고 작은 게임이라도 엔진을 구성하면 코드량이 꽤 많아지므로, **폴더/파일 구조를 체계적**으로 유지해야 합니다. 모듈별로 디렉토리를 나누고, 헤더와 소스 파일을 분리하며, 클래스 설계 변경이 필요한 경우 주석과 문서를 업데이트하세요.
- **확장과 재사용 고려**: 엔진을 처음부터 완벽하게 만들 수는 없지만, **확장에 대비한 설계**를 염두에 두세요. 예를 들어 현재 2D 전용으로 만들지만, 나중에 3D 기능을 붙이려면 어떻게 구조를 바꿔야 할지 가정해보는 것입니다. **오버엔지니어링은 금물**이지만, 기본기능을 구현하면서 “이 부분을 일반화하면 다른 게임에도 쓸 수 있겠다” 싶은 건 분리해두는 것이 좋습니다. 반대로 **현재 게임에 불필요한 기능은 과감히 제외**해서 복잡도를 낮추세요. 처음부터 모든 기능을 넣기보다, **작동하는 최소 엔진**을 만든 후 필요 시 기능을 추가하는 방식이 효율적입니다. 이때 엔진을 사용하는 **첫 번째 게임**을 테스트베드로 삼아, 실제 게임이 요구하는 기능 위주로 엔진을 다듬으면 과도한 설계를 피할 수 있습니다[stackoverflow.com](https://stackoverflow.com/questions/743947/what-should-be-in-a-2d-game-engine#:~:text=What%20should%20be%20in%20your,engine%20is%20the%20following)[stackoverflow.com](https://stackoverflow.com/questions/743947/what-should-be-in-a-2d-game-engine#:~:text=Anything%20that%20was%20reused%20should,is%20now%20your%20game%20engine).
- **효율성과 최적화**: 엔진을 설계할 때부터 성능을 고려하되, **조기 최적화**는 피하세요. 먼저 구조의 명확성과 기능의 정확성을 우선하고, **프로파일링**을 통해 병목이 되는 부분을 찾아 최적화합니다[reddit.com](https://www.reddit.com/r/gamedev/comments/43kpzg/proper_2d_game_engine_structure/#:~:text=Though%20it%27s%20more%20for%203D,Good%20luck%20on%20your%20adventures). 그래픽스의 경우 **드로우콜 최소화**(스프라이트 합치기, 배치 순서 최적화 등), 물리의 경우 **공간 분할 자료구조**(쿼드트리 등으로 충돌 검사 가속) 등을 나중에라도 도입할 수 있게 모듈화해두면 좋습니다. 또한 멀티스레딩은 2D 엔진에서는 복잡할 수 있지만, 로딩이나 사운드 처리 등을 별도 스레드로 분리할 여지를 염두에 둘 수 있습니다. DirectX11 자체는 멀티스레드 드로잉이 쉽지 않으므로, 대부분 메인 스레드에서 돌리되 **Update와 Render 분리** 등은 시도할 수 있습니다. **배치 방식**(Batching)으로 한 번에 많은 스프라이트를 그리거나, 필요 없는 업데이트는 건너뛰는 등 작은 최적화도 중요합니다. 결국, 엔진 개발 단계에서 **지속적인 테스트와 프로파일링**으로 효율을 개선해나가고, 설계 단계에서는 추후 최적화가 쉽게 모듈 교체나 수정으로 가능한 구조를 지향하면 됩니다.

以上의 원칙들을 지키면, DirectX11 2D 엔진의 **유지보수성**(코드 수정과 기능 추가가 용이), **확장성**(다른 게임이나 새로운 기능으로 확장 가능), **효율성**(성능과 자원 관리)이 향상됩니다. 특히 처음 엔진을 만들면서는 모든 것을 완벽히 하기 어렵지만, **코드의 구조적 품질**에 신경 쓰는 연습이 중요합니다. 작은 규칙들이 쌓여 큰 차이를 만들므로, 업데이트 순서 준수, 전역 변수 최소화, 명시적 의존 관계, 적절한 디자인 패턴 활용 등의 규칙을 개발 과정 내내 체크하세요. 필요하다면 간단한 흐름도나 UML을 그려보며 설계를 검증하는 것도 좋습니다 (예: 모듈 상호작용 다이어그램을 그려보고 순환 참조가 없는지 확인하는 식으로).

마지막으로, **엔진과 게임 개발의 균형**도 유념하세요. 엔진은 궁극적으로 게임을 만들기 위한 도구이므로, 엔진 개발 단계에서도 수시로 작은 데모 **게임 플레이를 테스트**하여 엔진 구조의 문제점을 발견하고 개선해야 합니다[stackoverflow.com](https://stackoverflow.com/questions/743947/what-should-be-in-a-2d-game-engine#:~:text=Once%20you%20have%20that%20game%2C,reused%20from%20the%20first%20game)[stackoverflow.com](https://stackoverflow.com/questions/743947/what-should-be-in-a-2d-game-engine#:~:text=A%20good%20implementation%20of%20an,you%27re%20writing%20is%20actually%20useful). 이렇게 하면 배우면서 바로바로 엔진을 개선하는 선순환이 이루어집니다. **직접 엔진을 제작**하는 과정은 쉽지 않지만, 위의 모듈 구성과 설계 원칙을 따라 하나씩 구현해나가면 큰 틀에서 안정적이고 유지보수하기 쉬운 2D 게임 엔진을 만들 수 있을 것입니다. 즐거운 개발 되시길 바랍니다!

**참고 자료:** DirectX11 게임 엔진 설계 관련 블로그[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=Platform%20%EB%8B%A8%EA%B3%84%20%3A%20%EC%96%B4%EB%96%A4%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C,%EA%B8%B0%ED%83%80%20%EC%99%B8%EB%B6%80%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%28%EC%84%9C%EB%93%9C%ED%8C%8C%ED%8B%B0)[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=3.%20%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%203,%EB%A0%88%EB%B2%A8%EC%9D%98%20%EC%A0%95%EC%9D%98%EB%8A%94%20%EB%8B%A4%EB%A5%BC%20%EC%88%98%20%EC%9E%88%EB%8B%A4), 게임 엔진 아키텍처 개요 자료[numberanalytics.com](https://www.numberanalytics.com/blog/game-engine-architecture-essentials#:~:text=The%20following%20diagram%20illustrates%20the,of%20a%20game%20engine%20architecture)[numberanalytics.com](https://www.numberanalytics.com/blog/game-engine-architecture-essentials#:~:text=Modularity), Unity 등 상용 엔진의 디자인 패턴 사례[rito15.github.io](https://rito15.github.io/posts/unity-deltatime-and-fixeddeltatime/#:~:text=%ED%83%80%EA%B2%9F%20%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EB%A7%88%EB%8B%A4%20%EC%84%B1%EB%8A%A5%20%EA%B2%A9%EC%B0%A8%EB%A1%9C%20%EC%9D%B8%ED%95%B4,%EA%B2%83%EC%9D%84%20%EB%8C%80%EB%B9%84%ED%95%B4%20%EB%B3%B4%EC%A0%95%ED%95%98%EA%B8%B0%20%EC%9C%84%ED%95%B4%20%EC%82%AC%EC%9A%A9%EB%90%9C%EB%8B%A4)[kabu0129.tistory.com](https://kabu0129.tistory.com/69#:~:text=3.%20%EC%BD%94%EB%94%A9%20%EC%8A%A4%ED%83%A0%EB%8B%A4%EB%93%9C%EB%A5%BC%20%EC%A4%80%EC%88%98%ED%95%9C%EB%8B%A4.%20,%EC%BD%94%EB%93%9C%EB%8A%94%20%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4) 등.